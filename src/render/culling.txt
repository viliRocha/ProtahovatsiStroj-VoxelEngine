func BuildChunkMesh(chunk *pkg.Chunk, chunkPos rl.Vector3) {
	var vertices []float32
	var indices []uint16
	var colors []uint8
	indexOffset := uint16(0)

	Nx, Ny, Nz := int(pkg.ChunkSize), int(pkg.ChunkSize), int(pkg.ChunkSize)
	for i := 0; i < Nx*Ny*Nz; i++ {
		pos := pkg.Coords{
			X: i / (Ny * Nz),
			Y: (i / Nz) % Ny,
			Z: i % Nz,
		}

		voxel := chunk.Voxels[pos.X][pos.Y][pos.Z]
		block := world.BlockTypes[voxel.Type]

		if !block.IsVisible {
			continue
		}

		c := block.Color

		for face := 0; face < 6; face++ {
			if !shouldDrawFace(chunk, pos, face) {
				continue
			}

			for vertice := 0; vertice < 4; vertice++ {
				v := pkg.FaceVertices[face][vertice]
				vertices = append(vertices,
					float32(pos.X)+v[0],
					float32(pos.Y)+v[1],
					float32(pos.Z)+v[2],
				)
				colors = append(colors, c.R, c.G, c.B, c.A)
			}

			indices = append(indices,
				indexOffset, indexOffset+1, indexOffset+2,
				indexOffset, indexOffset+2, indexOffset+3,
			)
			indexOffset += 4
		}
	}

	// Se ainda não criamos o model/material, faça uma vez
	if !chunk.HasMesh {
		// Mesh começa como zero-value; será preenchido antes do primeiro UploadMesh
		chunk.Mesh = rl.Mesh{}

		// Cria o Model a partir do Mesh
		chunk.Model = rl.LoadModelFromMesh(chunk.Mesh)

		// Cria um material padrão e atribui o ponteiro
		material := rl.LoadMaterialDefault()
		chunk.Model.MaterialCount = 1
		chunk.Model.Materials = &material

		chunk.HasMesh = true
	}

	// Preencha seus slices vertices, indices, colors como você já faz
	chunk.Mesh.VertexCount = int32(len(vertices) / 3)
	chunk.Mesh.TriangleCount = int32(len(indices) / 3)

	// Importante: só atribua ponteiros se houver dados
	if len(vertices) > 0 {
		chunk.Mesh.Vertices = &vertices[0]
		chunk.Mesh.VertexCount = int32(len(vertices) / 3)
	} else {
		chunk.Mesh.Vertices = nil
		chunk.Mesh.VertexCount = 0
	}

	if len(indices) > 0 {
		chunk.Mesh.Indices = &indices[0] // *uint16
	} else {
		chunk.Mesh.Indices = nil
	}

	if len(colors) > 0 {
		chunk.Mesh.Colors = &colors[0] // *uint8
	} else {
		chunk.Mesh.Colors = nil
	}

	// Envia para GPU, reaproveitando o mesmo Mesh
	rl.UploadMesh(&chunk.Mesh, false)

	// Atualiza a referência do Model para o Mesh (necessário após UploadMesh)
	chunk.Model.MeshCount = 1
	chunk.Model.Meshes = &chunk.Mesh

	chunk.IsOutdated = false
}