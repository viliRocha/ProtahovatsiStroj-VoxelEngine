	// Se o Model ainda não existe, cria uma vez
	if chunk.Model.MeshCount == 0 {
		maxFaces := pkg.ChunkSize * pkg.WorldHeight * pkg.ChunkSize * 6

		// Aloca buffers
		chunk.Vertices = make([]float32, 0, maxFaces*4*3)
		chunk.Normals = make([]float32, 0, maxFaces*4*3)
		chunk.Colors = make([]uint8, 0, maxFaces*4*4)
		chunk.Indices = make([]uint16, 0, maxFaces*6)

		mesh := rl.Mesh{}

		// ⚠️ ponteiros APONTAM PARA MEMÓRIA DO CHUNK
		mesh.Vertices = &chunk.Vertices[:cap(chunk.Vertices)][0]
		mesh.Normals = &chunk.Normals[:cap(chunk.Normals)][0]
		mesh.Colors = &chunk.Colors[:cap(chunk.Colors)][0]
		mesh.Indices = &chunk.Indices[:cap(chunk.Indices)][0]

		mesh.VertexCount = int32(cap(chunk.Vertices) / 3)
		mesh.TriangleCount = int32(cap(chunk.Indices) / 3)

		rl.UploadMesh(&mesh, true) // true = dynamic mesh
		model := rl.LoadModelFromMesh(mesh)

		// Create material and assign it
		material := rl.LoadMaterialDefault()
		material.Shader = game.Shader
		model.MaterialCount = 1
		model.Materials = &material

		chunk.Model = model
	}

	// Atualiza ponteiros do mesh para os buffers atuais
	mesh := chunk.Model.Meshes

	if len(chunk.Vertices) > 0 {
		rl.UpdateMeshBuffer(*mesh, 0, float32SliceToBytes(chunk.Vertices), len(chunk.Vertices)*4)
		rl.UpdateMeshBuffer(*mesh, 2, float32SliceToBytes(chunk.Normals), len(chunk.Normals)*4)
		rl.UpdateMeshBuffer(*mesh, 3, chunk.Colors, len(chunk.Colors))
		rl.UpdateMeshBuffer(*mesh, 6, uint16SliceToBytes(chunk.Indices), len(chunk.Indices)*2)
	}

	mesh.VertexCount = int32(len(chunk.Vertices) / 3)
	mesh.TriangleCount = int32(len(chunk.Indices) / 3)